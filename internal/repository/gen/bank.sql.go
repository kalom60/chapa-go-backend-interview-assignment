// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: bank.sql

package gen

import (
	"context"
)

const CountBanks = `-- name: CountBanks :one
SELECT COUNT(*) FROM bank
`

func (q *Queries) CountBanks(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountBanks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetAllBanks = `-- name: GetAllBanks :many
SELECT id, bank_id, slug, swift, name, acct_length, country_id, is_mobilemoney, is_active, is_rtgs, active, is_24hrs, currency, created_at, updated_at
FROM bank
LIMIT $1 OFFSET $2
`

type GetAllBanksParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetAllBanks(ctx context.Context, arg GetAllBanksParams) ([]Bank, error) {
	rows, err := q.db.Query(ctx, GetAllBanks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bank
	for rows.Next() {
		var i Bank
		if err := rows.Scan(
			&i.ID,
			&i.BankID,
			&i.Slug,
			&i.Swift,
			&i.Name,
			&i.AcctLength,
			&i.CountryID,
			&i.IsMobilemoney,
			&i.IsActive,
			&i.IsRtgs,
			&i.Active,
			&i.Is24hrs,
			&i.Currency,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetBankByBankID = `-- name: GetBankByBankID :one
SELECT id, bank_id, slug, swift, name, acct_length, country_id, is_mobilemoney, is_active, is_rtgs, active, is_24hrs, currency, created_at, updated_at
FROM bank
WHERE bank_id = $1
`

func (q *Queries) GetBankByBankID(ctx context.Context, bankID int32) (Bank, error) {
	row := q.db.QueryRow(ctx, GetBankByBankID, bankID)
	var i Bank
	err := row.Scan(
		&i.ID,
		&i.BankID,
		&i.Slug,
		&i.Swift,
		&i.Name,
		&i.AcctLength,
		&i.CountryID,
		&i.IsMobilemoney,
		&i.IsActive,
		&i.IsRtgs,
		&i.Active,
		&i.Is24hrs,
		&i.Currency,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
