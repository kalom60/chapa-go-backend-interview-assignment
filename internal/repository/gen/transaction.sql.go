// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: transaction.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountTransactions = `-- name: CountTransactions :one
SELECT COUNT(*) FROM transaction
`

func (q *Queries) CountTransactions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountTransactions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateTransaction = `-- name: CreateTransaction :one
INSERT INTO transaction(
    status, ref_id, type, created_at, currency, amount, charge,
    trans_id, payment_method, customer_id, customer_first_name, customer_last_name,customer_mobile
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING status, ref_id, type, created_at, currency, amount, charge, trans_id, payment_method, customer_id, customer_email, customer_first_name, customer_last_name, customer_mobile
`

type CreateTransactionParams struct {
	Status            string
	RefID             string
	Type              string
	CreatedAt         pgtype.Timestamp
	Currency          string
	Amount            float64
	Charge            float64
	TransID           pgtype.Text
	PaymentMethod     string
	CustomerID        string
	CustomerFirstName pgtype.Text
	CustomerLastName  pgtype.Text
	CustomerMobile    pgtype.Text
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, CreateTransaction,
		arg.Status,
		arg.RefID,
		arg.Type,
		arg.CreatedAt,
		arg.Currency,
		arg.Amount,
		arg.Charge,
		arg.TransID,
		arg.PaymentMethod,
		arg.CustomerID,
		arg.CustomerFirstName,
		arg.CustomerLastName,
		arg.CustomerMobile,
	)
	var i Transaction
	err := row.Scan(
		&i.Status,
		&i.RefID,
		&i.Type,
		&i.CreatedAt,
		&i.Currency,
		&i.Amount,
		&i.Charge,
		&i.TransID,
		&i.PaymentMethod,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerFirstName,
		&i.CustomerLastName,
		&i.CustomerMobile,
	)
	return i, err
}

const GetAllTransactions = `-- name: GetAllTransactions :many
SELECT status, ref_id, type, created_at, currency, amount, charge, trans_id, payment_method, customer_id, customer_email, customer_first_name, customer_last_name, customer_mobile
FROM transaction
LIMIT $1 OFFSET $2
`

type GetAllTransactionsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetAllTransactions(ctx context.Context, arg GetAllTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, GetAllTransactions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.Status,
			&i.RefID,
			&i.Type,
			&i.CreatedAt,
			&i.Currency,
			&i.Amount,
			&i.Charge,
			&i.TransID,
			&i.PaymentMethod,
			&i.CustomerID,
			&i.CustomerEmail,
			&i.CustomerFirstName,
			&i.CustomerLastName,
			&i.CustomerMobile,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTransactionByRef = `-- name: GetTransactionByRef :one
SELECT status, ref_id, type, created_at, currency, amount, charge, trans_id, payment_method, customer_id, customer_email, customer_first_name, customer_last_name, customer_mobile
FROM transaction
WHERE ref_id= $1
`

func (q *Queries) GetTransactionByRef(ctx context.Context, refID string) (Transaction, error) {
	row := q.db.QueryRow(ctx, GetTransactionByRef, refID)
	var i Transaction
	err := row.Scan(
		&i.Status,
		&i.RefID,
		&i.Type,
		&i.CreatedAt,
		&i.Currency,
		&i.Amount,
		&i.Charge,
		&i.TransID,
		&i.PaymentMethod,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerFirstName,
		&i.CustomerLastName,
		&i.CustomerMobile,
	)
	return i, err
}

const UpdateTransaction = `-- name: UpdateTransaction :one
UPDATE transaction
SET
    status= $2,
    ref_id= $3,
    type= $4,
    created_at= $5,
    currency= $6,
    amount= $7,
    charge= $8,
    trans_id= $9,
    payment_method= $10,
    customer_id= $11,
    customer_first_name= $12,
    customer_last_name= $13,
    customer_mobile= $14
WHERE ref_id= $1
RETURNING status, ref_id, type, created_at, currency, amount, charge, trans_id, payment_method, customer_id, customer_email, customer_first_name, customer_last_name, customer_mobile
`

type UpdateTransactionParams struct {
	RefID             string
	Status            string
	RefID_2           string
	Type              string
	CreatedAt         pgtype.Timestamp
	Currency          string
	Amount            float64
	Charge            float64
	TransID           pgtype.Text
	PaymentMethod     string
	CustomerID        string
	CustomerFirstName pgtype.Text
	CustomerLastName  pgtype.Text
	CustomerMobile    pgtype.Text
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, UpdateTransaction,
		arg.RefID,
		arg.Status,
		arg.RefID_2,
		arg.Type,
		arg.CreatedAt,
		arg.Currency,
		arg.Amount,
		arg.Charge,
		arg.TransID,
		arg.PaymentMethod,
		arg.CustomerID,
		arg.CustomerFirstName,
		arg.CustomerLastName,
		arg.CustomerMobile,
	)
	var i Transaction
	err := row.Scan(
		&i.Status,
		&i.RefID,
		&i.Type,
		&i.CreatedAt,
		&i.Currency,
		&i.Amount,
		&i.Charge,
		&i.TransID,
		&i.PaymentMethod,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerFirstName,
		&i.CustomerLastName,
		&i.CustomerMobile,
	)
	return i, err
}
